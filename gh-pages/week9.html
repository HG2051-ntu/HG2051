<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HG2051 – Week 9</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/main.css?v=1" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Week 9</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#learning-objectives" id="toc-learning-objectives">Learning
Objectives</a></li>
<li><a href="#reading" id="toc-reading">Reading</a>
<ul>
<li><a href="#higher-order-and-recursive-functions"
id="toc-higher-order-and-recursive-functions">Higher-order and Recursive
Functions</a></li>
<li><a href="#n-grams" id="toc-n-grams">N-grams</a></li>
<li><a href="#collocations" id="toc-collocations">Collocations</a></li>
<li><a href="#parts-of-speech"
id="toc-parts-of-speech">Parts-of-Speech</a></li>
</ul></li>
<li><a href="#testing-your-knowledge"
id="toc-testing-your-knowledge">Testing Your Knowledge</a>
<ul>
<li><a href="#questions" id="toc-questions">Questions</a></li>
<li><a href="#practical-work" id="toc-practical-work">Practical
Work</a></li>
</ul></li>
</ul>
</nav>
<main>
<h2 id="learning-objectives">Learning Objectives</h2>
<ul>
<li>Concepts: <span class="eng">higher-order functions</span> <span
class="eng">recursive functions</span> <span class="py">map()</span>
<span class="py">filter()</span> <span class="nlp">n-grams</span> <span
class="nlp">collocations</span> <span class="nlp">part-of-speech
tags</span></li>
</ul>
<p>(color key: <span class="py">Python/Programming</span> <span
class="nlp">NLP/CL</span> <span class="eng">Software
Engineering</span>)</p>
<h2 id="reading">Reading</h2>
<h3 id="higher-order-and-recursive-functions">Higher-order and Recursive
Functions</h3>
<h4 id="first-class-functions">First-class Functions</h4>
<p>By now you know how to define a function. For instance, to square a
number, you might write:</p>
<pre><code>```python
def square(x):
    return x ** 2
```</code></pre>
<p>Note that this definition does two things: (1) it defines the code
that, when called, accepts the <code>x</code> argument then computes and
returns the square of <code>x</code>; and (2) it assigns this “function
object” to the name <code>square</code>. When we invoke the name
<code>square</code> with parentheses and the appropriate arguments, we
get a result:</p>
<pre><code>```python
&gt;&gt;&gt; square(4)
16
```</code></pre>
<p>And if you just type the function name without calling it in an
interactive interpreter, Python will tell you it’s a function:</p>
<pre><code>```python
&gt;&gt;&gt; square
&lt;function square at 0x7ff9d780f790&gt;
```</code></pre>
<p>That is, the value of <code>square</code> is the function object.
This object is a value just like more traditional values in Python, such
as integers and strings, and we can reassign the function to another
variable if we like:</p>
<pre><code>```python
&gt;&gt;&gt; sq = square
&gt;&gt;&gt; sq(4)
16
```</code></pre>
<p>Python is said to have <a
href="https://en.wikipedia.org/wiki/First-class_function">first-class
functions</a>, meaning that functions are not merely something to be
called, but something that can be assigned, passed as arguments to other
functions, and used as the return value of another function.</p>
<h4 id="higher-order-functions">Higher-order Functions</h4>
<p>Functions are said to be <a
href="https://en.wikipedia.org/wiki/Higher-order_function">higher-order
functions</a> if they can accept other functions as arguments or if they
return a function as their result.</p>
<p>Continuing our example from before, we may wish to generalize
<code>square()</code> to a function that, given an exponent
<code>n</code>, returns a function that raises <code>x</code> to the
power of <code>n</code>:</p>
<pre><code>```python
def power(n):
    def raise_to(x):
        return x ** n
    return raise_to
```</code></pre>
<p>Then we could create <code>square</code> simply as follows:</p>
<pre><code>```python
&gt;&gt;&gt; square = power(2)
&gt;&gt;&gt; square(3)
9
&gt;&gt;&gt; cube = power(3)
&gt;&gt;&gt; cube(3)
27
```</code></pre>
<p>You don’t even need to assign the created function to use it:</p>
<pre><code>```python
&gt;&gt;&gt; power(3)(3)
27
```</code></pre>
<p>In Python, <a
href="https://docs.python.org/3/library/functions.html#map">map()</a>
and <a
href="https://docs.python.org/3/library/functions.html#filter">filter()</a>
are built-in functions that take a function as their first argument and
an iterable as their second argument. The <code>map()</code> function
applies the function argument to each item in the iterable and yields
the result:</p>
<pre><code>```python
&gt;&gt;&gt; list(map(square, range(10)))  # apply square() to each value in range(10)
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&gt;&gt;&gt; [square(x) for x in range(10)]  # this does the same thing in a comprehension
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```</code></pre>
<p><em>Note: <code>list()</code> is necessary to get the full list;
otherwise <code>map()</code> returns an iterator that yields one value
at a time.</em></p>
<p>The <code>filter()</code> function yields values from the iterable if
the function argument applied to the value evaluates as true.</p>
<pre><code>```python
&gt;&gt;&gt; list(filter(str.isnumeric, &#39;1 two 3 four 5&#39;.split()))
[&#39;1&#39;, &#39;3&#39;, &#39;5&#39;]
```</code></pre>
<p>We can see how this works by using <code>map()</code> to see the
<code>True</code>/<code>False</code> values, and noting that
<code>str.isnumeric(x)</code> is the same as <code>x.isnumeric()</code>
when <code>x</code> is a string:</p>
<pre><code>```python
&gt;&gt;&gt; &#39;1&#39;.isnumeric()  # the normal way to call `isnumeric()`
True
&gt;&gt;&gt; str.isnumeric(&#39;1&#39;)  # the functional way to call it
True
&gt;&gt;&gt; list(map(str.isnumeric, &#39;1 two 3 four 5&#39;.split()))
[True, False, True, False, True]
```</code></pre>
<p>To see how higher-order functions might help with NLP, please read
this short section from the NLTK book:</p>
<ul>
<li><a
href="http://www.nltk.org/book/ch04.html#higher-order-functions">NLTK
4.5 – Higher-Order Functions</a></li>
</ul>
<h4 id="recursive-functions">Recursive Functions</h4>
<p>You may know of recursive linguistic structures, such as grammatical
constructs which allow sentences like <em>Kim knows that Sandy knows
that Pat knows that the dog barked</em>. Similarly, many programming
languages allow <a
href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursive
functions</a> which call themselves. For example, you may want to write
a function that computes the factorial of some integer
<code>x</code>:</p>
<pre><code>```python
def factorial(x):
    # e.g., if x is 7, this would return 7 * factorial(6),
    # which returns 6 * factorial(5), etc.
    return x * factorial(x - 1)
```</code></pre>
<p>Let’s try it out:</p>
<pre><code>```python
&gt;&gt;&gt; factorial(7)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 2, in factorial
  File &quot;&lt;stdin&gt;&quot;, line 2, in factorial
  File &quot;&lt;stdin&gt;&quot;, line 2, in factorial
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
```</code></pre>
<p>Oops. This did <code>7 * (6 * (5 * ...))</code> but it did not stop
at 1, so it continued: <code>... * (0 * (-1 * ...))</code>. Recursive
functions must have a <em>base case</em> which decides when it should
stop. For instance:</p>
<pre><code>```python
def factorial(x):
    if x == 0:
        return 1  # base case
    else:
        return x * factorial(x - 1)
```</code></pre>
<p>And try again:</p>
<pre><code>```python
&gt;&gt;&gt; factorial(7)
5040
&gt;&gt;&gt; 7 * 6 * 5 * 4 * 3 * 2 * 1  # confirm
5040
```</code></pre>
<p>For some problems, recursive functions are the natural way to compute
a result, but they have limits (as seen by the
<code>RecursionError</code> above) and can lead to very inefficient
code. Recursive algorithms are often more efficient as an iterative loop
(<code>for</code>, <code>while</code>, etc.), but the iterative code can
be less intuitive.</p>
<h3 id="n-grams">N-grams</h3>
<p>Bigrams, Trigrams, and more generally n-grams are subsequences of
some sequence with length 2, 3, or more. In computational linguistics we
often use n-grams for sequences of tokens, words, characters, etc. The
NLTK has the <code>nltk.ngrams()</code> function which takes an iterable
and a number <code>n</code> and yields subsequence tuples of length
<code>n</code> from the iterable:</p>
<pre><code>```python
&gt;&gt;&gt; import nltk
&gt;&gt;&gt; four_words = &#39;many dogs chase cats&#39;.split()
&gt;&gt;&gt; list(nltk.ngrams(four_words, 1))  # unigrams
[(&#39;many&#39;,), (&#39;dogs&#39;,), (&#39;chase&#39;,), (&#39;cats&#39;,)]
&gt;&gt;&gt; list(nltk.ngrams(four_words, 2))  # bigrams
[(&#39;many&#39;, &#39;dogs&#39;), (&#39;dogs&#39;, &#39;chase&#39;), (&#39;chase&#39;, &#39;cats&#39;)]
&gt;&gt;&gt; list(nltk.ngrams(four_words, 3))  # trigrams
[(&#39;many&#39;, &#39;dogs&#39;, &#39;chase&#39;), (&#39;dogs&#39;, &#39;chase&#39;, &#39;cats&#39;)]
&gt;&gt;&gt; list(nltk.ngrams(four_words, 4))  # 4-grams
[(&#39;many&#39;, &#39;dogs&#39;, &#39;chase&#39;, &#39;cats&#39;)]
&gt;&gt;&gt; list(nltk.ngrams(four_words, 5))  # 5-grams
[]
```</code></pre>
<p><strong>See also:</strong> <a
href="https://books.google.com/ngrams#">Google’s Ngram Viewer</a></p>
<p>The items in the n-grams might be complex objects, such as n-grams of
word-tag pairs:</p>
<pre><code>```python
&gt;&gt;&gt; nltk.download(&#39;brown&#39;)  # if you don&#39;t have it yet
&gt;&gt;&gt; from nltk.corpus import brown
&gt;&gt;&gt; tagged_sent = brown.tagged_sents()[0]
&gt;&gt;&gt; tagged_sent[0:3]  # inspect some items
[(&#39;The&#39;, &#39;AT&#39;), (&#39;Fulton&#39;, &#39;NP-TL&#39;), (&#39;County&#39;, &#39;NN-TL&#39;)]
&gt;&gt;&gt; tagged_bigrams = list(nltk.ngrams(tagged_sent, 2))
&gt;&gt;&gt; for bigram in tagged_bigrams[:2]:  # inspect the first two bigrams
...     print(bigram)                  # note that each bigram is a word-tag pair
((&#39;The&#39;, &#39;AT&#39;), (&#39;Fulton&#39;, &#39;NP-TL&#39;))
((&#39;Fulton&#39;, &#39;NP-TL&#39;), (&#39;County&#39;, &#39;NN-TL&#39;))
```</code></pre>
<h3 id="collocations">Collocations</h3>
<p>N-grams of words that occur more often than you would expect in a
random distribution are called <a
href="https://en.wikipedia.org/wiki/Collocation">collocations</a>.
Furthermore, these words may have some special, perhaps
non-compositional meaning that wouldn’t be obvious by the individual
words. By counting the occurrences of n-gram pairs and comparing them to
the counts of the words individually, we can find those that tend to
appear together. For example:</p>
<pre><code>```python
def collocations(words):
    from operator import itemgetter
    # Count the words and bigrams
    wfd = nltk.FreqDist(words)
    pfd = nltk.FreqDist(nltk.bigrams(words))  # bigrams is the same as nltk.ngrams(words, 2)
    # Compute the scores for each pair
    scored = [((w1, w2), score(w1, w2, wfd, pfd)) for w1, w2 in pfd]
    ## sort according to the score
    scored.sort(key=itemgetter(1), reverse=True)
    return [p for (p, s) in scored]
```


```python
def score(word1, word2, wfd, pfd, power=3):
    &#39;&#39;&#39;return the collocation score f(w1,w2)^power/(f(w1)*f(w2))&#39;&#39;&#39;
    freq1 = wfd[word1]
    freq2 = wfd[word2]
    freq12 = pfd[(word1, word2)]
    return freq12 ** power / float(freq1 * freq2)
```</code></pre>
<p>And in use:</p>
<pre><code>```python
&gt;&gt;&gt; from nltk.corpus import gutenberg
&gt;&gt;&gt; words = [w for w in gutenberg.words(&#39;melville-moby_dick.txt&#39;) if len(w) &gt; 2]
&gt;&gt;&gt; print(collocations(words)[:10])
[(&#39;Moby&#39;, &#39;Dick&#39;), (&#39;Sperm&#39;, &#39;Whale&#39;), (&#39;White&#39;, &#39;Whale&#39;), (&#39;Dough&#39;, &#39;Boy&#39;),
(&#39;Mrs&#39;, &#39;Hussey&#39;), (&#39;Sag&#39;, &#39;Harbor&#39;), (&#39;Father&#39;, &#39;Mapple&#39;), (&#39;New&#39;, &#39;Bedford&#39;),
(&#39;Fast&#39;, &#39;Fish&#39;), (&#39;have&#39;, &#39;been&#39;)]
```</code></pre>
<p>For further information (not required reading), see:</p>
<ul>
<li><a
href="http://mlwiki.org/index.php/Collocation_Extraction">http://mlwiki.org/index.php/Collocation_Extraction</a></li>
<li><a
href="http://www.collocations.de/">http://www.collocations.de/</a></li>
</ul>
<h3 id="parts-of-speech">Parts-of-Speech</h3>
<p>I assume you are familiar with word categories, namely “parts of
speech”. If not, please read or skim the <a
href="https://en.wikipedia.org/wiki/Part_of_speech">Wikipedia
article</a>. Then please read the following sections of the NLTK book
about part-of-speech tagging:</p>
<ul>
<li><a href="http://www.nltk.org/book/ch05.html">NLTK 5 – Categorizing
and Tagging Words</a>
<ul>
<li><a href="http://www.nltk.org/book/ch05.html#using-a-tagger">NLTK 5.1
– Using a Tagger</a></li>
<li><a href="http://www.nltk.org/book/ch05.html#tagged-corpora">NLTK 5.2
– Tagged Corpora</a></li>
</ul></li>
</ul>
<h2 id="testing-your-knowledge">Testing Your Knowledge</h2>
<h3 id="questions">Questions</h3>
<ul>
<li><p><strong>Q:</strong> If you have a list of length <code>m</code>,
how many bigrams will it have? Trigrams? n-grams in general?</p></li>
<li><p><strong>Q:</strong> How might you deal with the problem of
getting an n-gram from a sequence where the length of the sequence is
less than <code>n</code>?</p></li>
<li><p><strong>Q:</strong> Do all languages use the same parts of
speech? Does a single language have a clear and complete set of
parts-of-speech?</p></li>
<li><p><strong>Q:</strong> What is a <em>tagset</em>? What are examples
of tagsets?</p></li>
</ul>
<h3 id="practical-work">Practical Work</h3>
<ul>
<li><p>Write a recursive function <code>fib(x)</code> to compute the <a
href="https://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci
number</a> of <code>x</code>. Calling <code>fib(1)</code> should return
1, <code>fib(5)</code> returns 8, and so on. What happens if you call
<code>fib(20)</code>, <code>fib(30)</code>, or <code>fib(40)</code>?
(use Ctrl-C to kill a stuck process). Now try rewriting the recursive
function as an iterative function. Can you go higher than
<code>fib(40)</code>?</p></li>
<li><p>Write a function <code>bigrams(xs)</code> that takes a list
<code>xs</code> and returns a list of bigrams from
<code>xs</code>.</p></li>
<li><p>Write a function that takes a string of <code>word/TAG</code>
formatted pairs and returns the list of (word, tag) tuples (hint: use
<code>nltk.str2tuple()</code>)</p></li>
<li><p>Write a function that uses <code>nltk.map_tag()</code> to map a
list of (word, tag) pairs to the universal tagset.</p></li>
</ul>
</main>
</body>
</html>
